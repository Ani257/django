================================================================================
DIRECTORY TREE
================================================================================

./
    .env
    .gitignore
    AuctionPage.jsx
    CheckoutButton.jsx
    clean_tree.txt
    database.py
    eccowatt.db
    generate_state.py
    main.py
    models.py
    PayNowButton.jsx
    project_state.txt
    razorpay_router.py
    requirements.txt
    reset_db.py
    schema.sql
    SuccessPage.jsx
    test.html
    tree.txt
    frontend/
        .env.local
        .gitignore
        components.json
        eslint.config.mjs
        next-env.d.ts
        next.config.ts
        package-lock.json
        package.json
        postcss.config.mjs
        README.md
        tsconfig.json
        public/
            file.svg
            globe.svg
            next.svg
            vercel.svg
            window.svg
        src/
            app/
                favicon.ico
                globals.css
                layout.tsx
                page.tsx
                login/
                    page.tsx
            components/
                AuctionCard.tsx
                FigmaUIOverlay.tsx
                Header.tsx
                Hero.tsx
                RazorpayCheckout.tsx
                ui/
                    badge.tsx
                    button.tsx
                    card.tsx
                    input.tsx
            lib/
                utils.ts
            utils/
                supabase/
                    client.ts
    src/
        app/
            success/
                page.jsx

================================================================================
FILE: main.py
================================================================================

"""
Main application file for the Reverse Auction API.
"""

import os
from contextlib import asynccontextmanager
from datetime import datetime, timezone, timedelta
from typing import Any, Dict, List, Optional

import uvicorn
from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from supabase import Client, create_client

from database import create_db_and_tables
from razorpay_router import router as razorpay_router

# Ensure environment variables are loaded
load_dotenv(".env")
load_dotenv()

SUPABASE_URL = os.environ.get("SUPABASE_URL", "https://your-project.supabase.co")
SUPABASE_KEY = os.environ.get("SUPABASE_KEY", "your-anon-key")

supabase: Optional[Client] = None

try:
    if SUPABASE_URL == "https://your-project.supabase.co":
        print("Warning: Using placeholder SUPABASE_URL")

    if SUPABASE_URL and SUPABASE_KEY:
        supabase = create_client(SUPABASE_URL, SUPABASE_KEY)
except Exception as e:  # pylint: disable=broad-exception-caught
    print(f"Error initializing Supabase client: {e}")


class ConnectionManager:
    """Manages active WebSocket connections for products."""

    def __init__(self) -> None:
        # Store active connections per product:
        # {product_id: [websocket1, websocket2, ...]}
        self.active_connections: Dict[str, List[WebSocket]] = {}

    async def connect(self, websocket: WebSocket, product_id: str) -> None:
        """Accept and store a new WebSocket connection."""
        await websocket.accept()
        if product_id not in self.active_connections:
            self.active_connections[product_id] = []
        self.active_connections[product_id].append(websocket)

    def disconnect(self, websocket: WebSocket, product_id: str) -> None:
        """Remove a disconnected WebSocket."""
        if product_id in self.active_connections:
            if websocket in self.active_connections[product_id]:
                self.active_connections[product_id].remove(websocket)
            if not self.active_connections[product_id]:
                self.active_connections.pop(product_id, None)

    async def broadcast(self, message: Dict[str, Any], product_id: str) -> None:
        """Send a JSON message to all connected clients for a product."""
        if product_id in self.active_connections:
            for connection in list(self.active_connections[product_id]):
                try:
                    await connection.send_json(message)
                except RuntimeError:
                    pass


manager = ConnectionManager()


# Allowed origins
FRONTEND_URL = os.getenv("FRONTEND_URL", "http://localhost:3000")
ALLOWED_ORIGINS = [
    FRONTEND_URL,
    "http://localhost:3000",   # Next.js dev server
    "http://127.0.0.1:3000",
    "https://*.vercel.app",    # Allows all Vercel subdomains
    "*",                       # Temporarily allow all for local testing
]

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Create DB tables on startup."""
    create_db_and_tables()
    yield

app = FastAPI(title="Reverse Auction API", version="1.0.0", lifespan=lifespan)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,  # Allows specified origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods
    allow_headers=["*"],  # Allows all headers
)

app.include_router(razorpay_router)


@app.get("/")
def read_root() -> Dict[str, str]:
    """Root endpoint."""
    return {"status": "ok", "message": "Welcome to the Reverse Auction API"}


@app.get("/products")
def get_products() -> Dict[str, Any]:
    """Retrieve all products from Supabase."""
    if not supabase:
        return {"error": "Supabase client not initialized properly."}

    assert supabase is not None
    # Example of querying the Products table
    response = supabase.table("products").select("*").execute()
    return {"data": response.data}


@app.websocket("/ws/auction/{product_id}")
async def websocket_auction_endpoint(
    websocket: WebSocket, product_id: str
) -> None:
    """WebSocket endpoint for live auction updates and bidding."""
    await manager.connect(websocket, product_id)
    if not supabase:
        await websocket.send_json(
            {"error": "Supabase client not initialized properly."}
        )
        manager.disconnect(websocket, product_id)
        return

    assert supabase is not None

    try:
        while True:
            data = await websocket.receive_json()
            if data.get("action") == "share_click":
                user_id = data.get("user_id")

                if not user_id:
                    await websocket.send_json({"error": "User ID is required to share"})
                    continue

                # 1. Try to record the share
                try:
                    share_response = (
                        supabase.table("user_shares")
                        .insert({"user_id": user_id, "product_id": product_id})
                        .execute()
                    )
                except Exception as e:
                    # Supabase python client raises an exception on constraint failure
                    err_message = str(e)
                    if "duplicate key value violates unique constraint" in err_message.lower():
                        await websocket.send_json({"error": "You have already shared this drop!"})
                    else:
                        await websocket.send_json({"error": "Could not record share"})
                    continue

                if getattr(share_response, 'error', None) and share_response.error:
                     # For some client versions, errors are returned instead of raised
                     if share_response.error.code == "23505": # PostgreSQL unique violation code
                         await websocket.send_json({"error": "You have already shared this drop!"})
                     else:
                        await websocket.send_json({"error": "Could not record share"})
                     continue

                # 2. Query current state of the product
                response = (
                    supabase.table("products")
                    .select("current_price, minimum_price, drop_time")
                    .eq("id", product_id)
                    .execute()
                )

                if not response.data or len(response.data) == 0:
                    await websocket.send_json({"error": "Product not found"})
                    continue

                product = response.data[0]
                if not isinstance(product, dict):
                    continue

                current_price = float(product.get("current_price", 0))
                minimum_price = float(product.get("minimum_price", 0))

                # Check drop_time
                drop_time_str = product.get("drop_time")
                if isinstance(drop_time_str, str):
                    # Handle Supabase Z notation for UTC
                    drop_time_parsed = datetime.fromisoformat(
                        drop_time_str.replace("Z", "+00:00")
                    )
                    now_utc = datetime.now(timezone.utc)
                    if now_utc < drop_time_parsed:
                        err = {"error": "Drop has not started yet"}
                        await websocket.send_json(err)
                        
                        # Rollback share if drop hasn't started?
                        # Probably better to just keep it recorded or prevent click UI wise
                        continue
                        
                    if now_utc > drop_time_parsed + timedelta(hours=24):
                        err = {"error": "The drop has ended! Processing winners..."}
                        await websocket.send_json(err)
                        continue

                # 3. Deduct price if it hasn't reached minimum
                if current_price > minimum_price:
                    # Ensure we don't drop below minimum
                    new_price = max(current_price - 1.0, minimum_price)

                    # 4. Update the new price in database
                    update_response = (
                        supabase.table("products")
                        .update({"current_price": new_price})
                        .eq("id", product_id)
                        .execute()
                    )

                    if update_response.data and len(update_response.data) > 0:
                        # 5. Broadcast the new price
                        updated_product = update_response.data[0]
                        if isinstance(updated_product, dict):
                            new_val = float(
                                updated_product.get("current_price", 0)
                            )
                            await manager.broadcast(
                                {
                                    "type": "price_update",
                                    "product_id": product_id,
                                    "new_price": new_val,
                                },
                                product_id,
                            )
                    else:
                        await websocket.send_json(
                            {"error": "Failed to update price"}
                        )
                else:
                    msg = {"message": "Price has reached the minimum limit."}
                    await websocket.send_json(msg)

    except WebSocketDisconnect:
        manager.disconnect(websocket, product_id)
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"WebSocket Error: {e}")
        manager.disconnect(websocket, product_id)


if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)

================================================================================
FILE: frontend/src/components/AuctionCard.tsx
================================================================================

'use client';

import React, { useEffect, useState, useRef } from 'react';
import RazorpayCheckout from './RazorpayCheckout';
import { createClient } from '@/utils/supabase/client';
import { Button } from '@/components/ui/button';
import { ExternalLink } from 'lucide-react';

// Using the same active UUID from our database
const PRODUCT_ID = '6ca22814-c1a4-42e2-bec5-fdb388806692';

const AuctionCard = () => {
    const [price, setPrice] = useState<number | null>(null);
    const [status, setStatus] = useState<'connecting' | 'connected' | 'disconnected'>('connecting');
    const [dropTime, setDropTime] = useState<Date | null>(null);
    const [brandUrl, setBrandUrl] = useState<string | null>(null);
    const [timeRemaining, setTimeRemaining] = useState<number>(0); // Time in milliseconds
    const [isEnded, setIsEnded] = useState<boolean>(false);
    const [errorMsg, setErrorMsg] = useState<string | null>(null); // State for WebSocket errors

    const wsRef = useRef<WebSocket | null>(null);
    const supabase = createClient();

    // Fetch initial product data from Supabase
    useEffect(() => {
        const fetchProductData = async () => {
            const { data, error } = await supabase
                .from('products')
                .select('current_price, drop_time, brand_url')
                .eq('id', PRODUCT_ID)
                .single();

            if (error) {
                console.error("Error fetching product data:", error);
                return;
            }

            if (data) {
                setPrice(parseFloat(data.current_price));
                setBrandUrl(data.brand_url || null);
                if (data.drop_time) {
                    setDropTime(new Date(data.drop_time));
                }
            }
        };

        fetchProductData();
    }, [supabase]);

    // WebSocket logic
    useEffect(() => {
        if (isEnded) return; // Do not connect if ended

        const ws = new WebSocket(`ws://localhost:8000/ws/auction/${PRODUCT_ID}`);
        wsRef.current = ws;

        ws.onopen = () => {
            setStatus('connected');
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'price_update') {
                setPrice(data.new_price);
                setErrorMsg(null); // Clear errors on a successful price drop
            } else if (data.error) {
                // If the backend blocked the share (e.g. unique constraint), show the error.
                setErrorMsg(data.error);

                if (data.error.includes("The drop has ended")) {
                    setIsEnded(true);
                }

                // Clear the error message automatically after 3 seconds
                setTimeout(() => {
                    setErrorMsg(null);
                }, 3000);
            }
        };

        ws.onclose = () => {
            setStatus('disconnected');
        };

        ws.onerror = (error) => {
            console.error('WebSocket Error:', error);
            setStatus('disconnected');
        };

        return () => {
            if (wsRef.current) {
                wsRef.current.close();
            }
        };
    }, [isEnded]);

    // Countdown Timer logic
    useEffect(() => {
        if (!dropTime) return;

        const calculateTimeRemaining = () => {
            const now = new Date().getTime();
            const target = dropTime.getTime();
            const endTarget = target + (24 * 60 * 60 * 1000); // 24 hours later

            if (now >= endTarget) {
                // Drop has ended!
                setIsEnded(true);
                setTimeRemaining(0);
                if (wsRef.current) {
                    wsRef.current.close();
                }
            } else if (now >= target) {
                // Drop is active. Count down to end target? Or just keep it 0 as user stated.
                // We will count down to 0 for start as original logic, but here if user wanted 0 to mean end:
                // "If timeRemaining === 0 (meaning the countdown has finished): Change the ... text to DROP ENDED"
                // To adhere precisely, let's keep timeRemaining as time till start, but when it's over, `isEnded` is true
                setTimeRemaining(0);
            } else {
                // Drop hasn't started yet
                const difference = target - now;
                setTimeRemaining(Math.max(0, difference));
            }
        };

        // Calculate immediately 
        calculateTimeRemaining();

        // Update every second
        const intervalId = setInterval(calculateTimeRemaining, 1000);

        return () => clearInterval(intervalId);
    }, [dropTime]);

    // Format millisecond duration to HH:MM:SS
    const formatTime = (milliseconds: number) => {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        return [hours, minutes, seconds]
            .map(v => v < 10 ? "0" + v : v)
            .join(":");
    };

    const handleShareClick = () => {
        // Double check not visually disabled and socket is alive
        if (!isLocked && !isEnded && wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
            // Include a dummy user ID to test the Supabase Unique constraints!
            const currentUserId = '123e4567-e89b-12d3-a456-426614174000';
            wsRef.current.send(JSON.stringify({
                action: 'share_click',
                user_id: currentUserId
            }));
        }
    };

    const isLocked = timeRemaining > 0;

    return (
        <div className="relative group overflow-hidden rounded-3xl bg-white border border-gray-200 p-8 shadow-xl transition-all flex flex-col items-center max-w-md mx-auto w-full">
            {/* Status indicator and Verify Link Header */}
            <div className="w-full flex justify-between items-center mb-6">
                {brandUrl ? (
                    <a
                        href={brandUrl}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="inline-flex items-center text-xs font-semibold text-blue-600 hover:text-blue-800 transition-colors"
                    >
                        Verify on Official Site <ExternalLink className="ml-1 w-3 h-3" />
                    </a>
                ) : (
                    <div></div> // Empty div to keep flex space-between intact
                )}

                <div className={`flex items-center gap-2 text-xs font-semibold px-2 py-1 rounded-full ${isEnded ? 'text-red-700 bg-red-100' : status === 'connected' ? 'text-green-700 bg-green-100' : 'text-amber-700 bg-amber-100'}`}>
                    {!isEnded && <span className={`h-2 w-2 rounded-full ${status === 'connected' ? 'bg-green-500 animate-pulse' : 'bg-amber-500'}`}></span>}
                    {isEnded ? 'Ended' : status === 'connected' ? 'Live' : 'Connecting...'}
                </div>
            </div>

            {/* Hype Timer Display */}
            {dropTime && !isEnded && (
                <div className="mb-8 w-full">
                    <h3 className="text-center text-xs font-bold tracking-widest text-red-500 uppercase mb-2">
                        {timeRemaining > 0 ? 'Drop Starts In' : 'Drop Status'}
                    </h3>
                    <div className="text-center bg-gray-50 rounded-2xl py-4 border border-gray-100">
                        {timeRemaining > 0 ? (
                            <span className="text-5xl font-black tracking-tighter tabular-nums text-gray-900">
                                {formatTime(timeRemaining)}
                            </span>
                        ) : (
                            <span className="text-3xl font-black text-green-600 tracking-tight animate-pulse">
                                LIVE NOW
                            </span>
                        )}
                    </div>
                </div>
            )}

            {isEnded && (
                <div className="mb-8 w-full">
                    <h3 className="text-center text-xs font-bold tracking-widest text-red-500 uppercase mb-2">Drop Status</h3>
                    <div className="text-center bg-gray-50 rounded-2xl py-4 border border-gray-100">
                        <span className="text-3xl font-black text-gray-900 tracking-tight">
                            COMPLETED
                        </span>
                    </div>
                </div>
            )}

            <h2 className="text-sm font-bold tracking-widest text-gray-400 uppercase mb-2">{isEnded ? 'Final Price' : 'Current Price'}</h2>

            <div className={`text-6xl sm:text-7xl font-black tracking-tighter mb-8 tabular-nums transition-colors duration-500 ${isLocked || isEnded ? 'text-gray-300' : 'text-gray-900'}`}>
                {price !== null ? `‚Çπ${price.toFixed(2)}` : '...'}
            </div>

            <Button
                onClick={handleShareClick}
                disabled={isLocked || isEnded || status !== 'connected'}
                className="w-full h-16 text-lg sm:text-xl font-black relative overflow-hidden group/btn shadow-lg rounded-2xl transition-all"
            >
                <div className="absolute inset-0 bg-gradient-to-r from-red-600 to-purple-600 opacity-0 transition-opacity duration-300 group-hover/btn:opacity-20 pointer-events-none"></div>
                {isEnded ? 'DROP ENDED' : isLocked ? 'LOCKED UNTIL DROP' : 'SHARE TO DROP PRICE (‚Çπ1)'}
            </Button>

            {/* Error Message Box */}
            {errorMsg && (
                <div className="mt-3 text-red-500 text-sm font-bold text-center animate-pulse">
                    ‚ö†Ô∏è {errorMsg}
                </div>
            )}

            <p className="text-xs text-gray-500 mt-4 text-center font-medium">
                {isEnded ? 'This drop has ended. No more drops available.' : isLocked ? 'Waiting for countdown to finish.' : 'Clicking reduces the price by ‚Çπ1 for EVERYONE.'}
            </p>

            <div className="w-full mt-6 pt-6 border-t border-gray-100">
                <RazorpayCheckout currentPrice={price} disabled={isEnded || isLocked} />
            </div>
        </div>
    );
};

export default AuctionCard;

================================================================================
FILE: frontend/src/components/RazorpayCheckout.tsx
================================================================================

'use client';

import React, { useState } from 'react';

// Extend window to support the Razorpay injected property
declare global {
    interface Window {
        Razorpay: any;
    }
}

interface RazorpayCheckoutProps {
    currentPrice: number | null;
    disabled?: boolean;
}

const RazorpayCheckout: React.FC<RazorpayCheckoutProps> = ({ currentPrice, disabled }) => {
    const [loading, setLoading] = useState(false);
    const [success, setSuccess] = useState(false);

    const handlePayment = async () => {
        if (!currentPrice) return;
        setLoading(true);

        try {
            // 1. Hit the backend mock order creation endpoint
            const orderRes = await fetch('http://localhost:8000/razorpay/create-order', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ amount: currentPrice, currency: 'INR' })
            });

            if (!orderRes.ok) throw new Error('Failed to create order');

            // 2. Simulate the Razorpay popup delay (1.5 seconds)
            await new Promise(resolve => setTimeout(resolve, 1500));

            // 3. Mark as successful!
            setSuccess(true);
            alert(`Payment Authorized at ‚Çπ${currentPrice}! Your intent is locked.`);

        } catch (error) {
            console.error('Checkout error:', error);
            alert('Error initiating checkout.');
        } finally {
            setLoading(false);
        }
    };

    if (success) {
        return (
            <div className="w-full mt-4 py-6 px-6 rounded-xl font-black border-2 bg-green-50 text-green-700 border-green-200 text-center shadow-inner text-xl">
                <span>üéâ INTENT LOCKED AT <span className="text-green-900 border-b-2 border-green-900">‚Çπ{currentPrice?.toFixed(2)}</span></span>
            </div>
        );
    }

    return (
        <button
            onClick={handlePayment}
            disabled={!currentPrice || loading}
            className={`w-full mt-4 py-4 px-6 rounded-xl font-bold border-2 flex justify-between items-center transition-all ${!currentPrice || loading
                ? 'bg-gray-200 text-gray-500 cursor-not-allowed border-gray-300'
                : 'bg-black text-white cursor-pointer hover:bg-gray-800 border-black shadow-xl ring-2 ring-black ring-offset-2'
                }`}
        >
            <span>{loading ? 'Processing Server...' : 'Lock Intent Now'}</span>
            <span>{currentPrice ? `‚Çπ${currentPrice.toFixed(2)}` : 'Wait...'}</span>
        </button>
    );
};

export default RazorpayCheckout;
